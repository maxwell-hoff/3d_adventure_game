<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Navigation + Stars (Three.js)</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    #overlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.92);
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.45), rgba(0,0,0,0.85));
      cursor: pointer;
      user-select: none;
    }
    #panel {
      width: min(560px, calc(100vw - 32px));
      border-radius: 16px;
      padding: 18px 18px 14px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      backdrop-filter: blur(6px);
      line-height: 1.35;
    }
    #panel h1 { font-size: 18px; margin: 0 0 10px; }
    #panel .k { display: inline-block; padding: 2px 6px; border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06);
      font-weight: 600;
    }
    #hint {
      position: fixed; left: 14px; bottom: 12px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: 520px;
      backdrop-filter: blur(6px);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="panel">
      <h1>3D Exploration Demo</h1>
      Click to start (locks mouse).<br/><br/>
      Move: <span class="k">W</span><span class="k">A</span><span class="k">S</span><span class="k">D</span>
      &nbsp;|&nbsp; Sprint: <span class="k">Shift</span>
      &nbsp;|&nbsp; Jump: <span class="k">Space</span><br/>
      Look: <span class="k">Mouse</span>
      &nbsp;|&nbsp; Release mouse: <span class="k">Esc</span><br/><br/>
      Goal: wander paths + trees, then look up at the star dome.
    </div>
  </div>
  <div id="hint">Tip: the “sky” is a star dome. Later you can add constellations, moon phase, latitude, etc.</div>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

    // --- Scene setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05070c, 30, 220);

    const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 2000);
    camera.position.set(0, 1.7, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- Pointer lock controls (mouse look + forward direction) ---
    const controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    const overlay = document.getElementById("overlay");
    overlay.addEventListener("click", () => controls.lock());
    controls.addEventListener("lock", () => overlay.style.display = "none");
    controls.addEventListener("unlock", () => overlay.style.display = "grid");

    // --- Lights ---
    scene.add(new THREE.AmbientLight(0x9fb6ff, 0.25));

    const moonLight = new THREE.DirectionalLight(0xcfe2ff, 0.55);
    moonLight.position.set(40, 80, 10);
    scene.add(moonLight);

    const warmFill = new THREE.DirectionalLight(0xffd9a6, 0.15);
    warmFill.position.set(-30, 25, -40);
    scene.add(warmFill);

    // --- Ground ---
    const groundGeo = new THREE.PlaneGeometry(500, 500, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x2f6b3a, roughness: 1.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = false;
    scene.add(ground);

    // Subtle ground variation (cheap: a few darker patches)
    function addPatch(x, z, r, color) {
      const g = new THREE.CircleGeometry(r, 24);
      const m = new THREE.MeshStandardMaterial({ color, roughness: 1.0 });
      const p = new THREE.Mesh(g, m);
      p.rotation.x = -Math.PI / 2;
      p.position.set(x, 0.01, z);
      scene.add(p);
    }
    for (let i=0;i<70;i++){
      addPatch((Math.random()-0.5)*350, (Math.random()-0.5)*350, 6+Math.random()*14, 0x2b5f34);
    }

    // --- Paths (simple strips) ---
    const pathMat = new THREE.MeshStandardMaterial({ color: 0xa58b5a, roughness: 1.0 });
    function addPathSegment(x, z, w, l, rotY=0) {
      const seg = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, l), pathMat);
      seg.position.set(x, 0.04, z);
      seg.rotation.y = rotY;
      scene.add(seg);
      return seg;
    }

    // Make a few meandering paths
    function carvePath(startX, startZ, steps, stepLen) {
      let x = startX, z = startZ;
      let ang = Math.random() * Math.PI * 2;
      for (let i=0;i<steps;i++){
        if (Math.random() < 0.12) ang += (Math.random()-0.5)*1.2;
        const nx = x + Math.cos(ang) * stepLen;
        const nz = z + Math.sin(ang) * stepLen;
        const midX = (x + nx)/2;
        const midZ = (z + nz)/2;
        const rot = Math.atan2(nz - z, nx - x);
        addPathSegment(midX, midZ, 5.0, stepLen + 0.5, -rot);
        x = nx; z = nz;
      }
    }
    carvePath(-60, 20, 75, 7);
    carvePath(40, -30, 75, 7);
    carvePath(0, 0, 55, 8);

    // --- Trees (cylinder trunk + cone canopy) ---
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5b3a22, roughness: 1.0 });
    const leafMat = new THREE.MeshStandardMaterial({ color: 0x1f4f2c, roughness: 1.0 });

    function addTree(x, z, s=1) {
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18*s, 0.22*s, 1.4*s, 10), trunkMat);
      trunk.position.set(x, 0.7*s, z);

      const canopy = new THREE.Mesh(new THREE.ConeGeometry(1.0*s, 2.2*s, 10), leafMat);
      canopy.position.set(x, 2.0*s, z);

      // small highlight blob to give some depth
      const hi = new THREE.Mesh(new THREE.SphereGeometry(0.45*s, 10, 10),
        new THREE.MeshStandardMaterial({ color: 0x2f6b3a, roughness: 1.0 })
      );
      hi.position.set(x-0.35*s, 2.2*s, z-0.25*s);

      scene.add(trunk, canopy, hi);
    }

    // Scatter trees, but keep a loose “path corridor” clearer
    function nearAnyPath(x, z) {
      // crude: just keep a few hardcoded corridors for this demo
      const corridors = [
        {x:-60, z:20, r:22},
        {x:40, z:-30, r:22},
        {x:0, z:0, r:20}
      ];
      for (const c of corridors) {
        const dx = x - c.x, dz = z - c.z;
        if ((dx*dx + dz*dz) < (c.r*c.r)) return true;
      }
      return false;
    }

    for (let i=0;i<650;i++){
      const x = (Math.random()-0.5)*360;
      const z = (Math.random()-0.5)*360;
      if (nearAnyPath(x,z) && Math.random() < 0.75) continue;
      addTree(x, z, 0.75 + Math.random()*0.9);
    }

    // --- Star dome (Points on a big sphere) ---
    function makeStarDome() {
      const starCount = 2400;
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);

      const radius = 900; // huge dome
      const color = new THREE.Color();

      for (let i=0;i<starCount;i++){
        // random direction, but bias toward "upper hemisphere"
        // (so stars are mostly above horizon)
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(THREE.MathUtils.lerp(0.05, 1.0, v)); // 0..pi/2-ish
        // convert to direction
        const x = Math.sin(phi) * Math.cos(theta);
        const y = Math.cos(phi); // up
        const z = Math.sin(phi) * Math.sin(theta);

        positions[i*3+0] = x * radius;
        positions[i*3+1] = y * radius;
        positions[i*3+2] = z * radius;

        // color temperature-ish (slight blue/white variation)
        const t = Math.random();
        color.setRGB(
          THREE.MathUtils.lerp(0.85, 1.0, t),
          THREE.MathUtils.lerp(0.90, 1.0, t),
          THREE.MathUtils.lerp(0.95, 1.0, 1-t)
        );
        colors[i*3+0] = color.r;
        colors[i*3+1] = color.g;
        colors[i*3+2] = color.b;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: 2.0,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        depthWrite: false
      });

      const points = new THREE.Points(geo, mat);
      points.frustumCulled = false;
      return points;
    }

    const starDome = makeStarDome();
    scene.add(starDome);

    // Also add a subtle dark sky gradient as a huge sphere behind stars
    const skyGeo = new THREE.SphereGeometry(950, 32, 16);
    const skyMat = new THREE.MeshBasicMaterial({ color: 0x04060a, side: THREE.BackSide });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // --- Movement / simple physics ---
    const key = { w:false,a:false,s:false,d:false, shift:false, space:false };
    addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k==="w") key.w = true;
      if (k==="a") key.a = true;
      if (k==="s") key.s = true;
      if (k==="d") key.d = true;
      if (k==="shift") key.shift = true;
      if (k===" ") key.space = true;
    });
    addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k==="w") key.w = false;
      if (k==="a") key.a = false;
      if (k==="s") key.s = false;
      if (k==="d") key.d = false;
      if (k==="shift") key.shift = false;
      if (k===" ") key.space = false;
    });

    let velocityY = 0;
    let onGround = true;

    const clock = new THREE.Clock();

    function animate() {
      const dt = Math.min(clock.getDelta(), 0.033);

      // slow rotation of star dome (feels like sky drift)
      starDome.rotation.y += dt * 0.02;

      if (controls.isLocked) {
        const speed = key.shift ? 8.0 : 4.5;

        // movement in camera-facing space, but keep it on XZ plane
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();

        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

        const move = new THREE.Vector3();
        if (key.w) move.add(forward);
        if (key.s) move.sub(forward);
        if (key.d) move.add(right);
        if (key.a) move.sub(right);

        if (move.lengthSq() > 0) {
          move.normalize().multiplyScalar(speed * dt);
          controls.getObject().position.add(move);
        }

        // keep player roughly within the world
        const p = controls.getObject().position;
        p.x = THREE.MathUtils.clamp(p.x, -240, 240);
        p.z = THREE.MathUtils.clamp(p.z, -240, 240);

        // jump + gravity
        if (key.space && onGround) {
          velocityY = 5.2;
          onGround = false;
        }
        velocityY -= 9.8 * dt;
        p.y += velocityY * dt;

        // ground collision
        if (p.y <= 1.7) {
          p.y = 1.7;
          velocityY = 0;
          onGround = true;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // --- Resize ---
    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });

  </script>
</body>
</html>
